import json
import networkx as nx
from collections import defaultdict
import shutil
import os
from gemd.util.impl import recursive_foreach
from gemd.json import GEMDJson

import matplotlib.pyplot as plt
from matplotlib.lines import Line2D
import matplotlib.colors as colors
import matplotlib.cm as cmx
import matplotlib.patches as mpatches
from matplotlib import pylab


# _encoder = None
# _subdirpath = None


def out(item):
    """
    function object to run on individual item during recursion
    :param item: json item to write its destination
    """
    fn = "_".join([item.__class__.__name__, item.name, item.uids["auto"], ".json"])
    with open(os.path.join(_subdirpath, fn), "w") as fp:
        fp.write(_encoder.thin_dumps(item, indent=3))


def handle_value(G, uid, attributes):
    # TODO: add pointing to templates?
    for att in attributes:
        if att["type"] == "property_and_conditions":
            value = att["property"]["value"]
            att_name = att["property"]["name"]
        else:
            value = att["value"]
            att_name = att["name"]

        if value["type"] == "nominal_real":
            node_name = "{}, {} {}".format(att_name, value["nominal"], value["units"])
            G.add_node(node_name, shape="rectangle", color="orange")
            G.add_edge(node_name, uid)
        if value["type"] == "nominal_categorical":
            node_name = "{}, {}".format(att_name, value["category"])
            G.add_node(node_name, shape="rectangle", color="orange")
            G.add_edge(node_name, uid)


def handle_attributes(G, uid, obj_data, object_class, obj_state):
    if "parameters" in obj_data:
        handle_value(G, uid, obj_data["parameters"])
    if "properties" in obj_data:
        handle_value(G, uid, obj_data["properties"])
    if "conditions" in obj_data:
        handle_value(G, uid, obj_data["conditions"])


def handle_gemd_obj(G, uid, obj_data, obj_type, obj_state, object_mapping):
    if obj_type.startswith("process"):
        if obj_type.endswith(obj_state):
            G.add_node(uid, color="red")
            handle_attributes(G, uid, obj_data, "process", obj_state)
    elif obj_type.startswith("ingredient"):  # TODO if node doesn't exist, create?
        if obj_type.endswith(obj_state):
            G.add_node(uid, color="blue")
            process = obj_data["process"]["id"]
            G.add_edge(uid, process)
            handle_attributes(G, uid, obj_data, "ingredient", obj_state)
            if "material" in obj_data:
                material = obj_data["material"]["id"]
                G.add_edge(material, uid)
    elif obj_type.startswith("material"):
        if obj_type.endswith(obj_state):
            G.add_node(uid, color="green")
            handle_attributes(G, uid, obj_data, "material", obj_state)
            # if "process" in obj_data and obj_data["process"]:
            if obj_data["process"]:
                process = obj_data["process"]["id"]
                G.add_edge(process, uid)  # ?
    elif obj_type.startswith("measurement"):
        if obj_type.endswith(obj_state):
            G.add_node(uid, color="purple")
            handle_attributes(G, uid, obj_data, "measurement", obj_state)
            if "material" in obj_data:
                material = obj_data["material"]["id"]
                G.add_edge(uid, material)


def save_graph(graph, file_name):
    plt.figure(num=None, figsize=(20, 20), dpi=80)
    plt.axis("off")
    fig = plt.figure(1)
    pos = nx.spring_layout(graph)
    nx.draw_networkx_nodes(graph, pos)
    nx.draw_networkx_edges(graph, pos)
    nx.draw_networkx_labels(graph, pos)

    cut = 1.00
    xmax = cut * max(xx for xx, yy in pos.values())
    ymax = cut * max(yy for xx, yy in pos.values())
    plt.xlim(0, xmax)
    plt.ylim(0, ymax)

    plt.savefig(file_name, bbox_inches="tight")
    pylab.close()
    del fig


def plot_graph(dirpath, obj_state="run", objectpath=None, tmp="tmp"):
    """
    creates a NetworkX graph representation of the GEMD relationships by reading every object
    generated by the GEMDEncoder object, storing all of its links by uid, and forming directed relationships,
    such as ingredient->process, or process->material
    It then allows filtering the objects mapped (i.e., removing spec or runs,
    measurements or ingredients) and saves a NetworkX graph in "dot" as .png

    :param dirpath: source of graph
    :param obj_state: to plot a graph of specs, runs or templates
    """
    G = nx.DiGraph()
    object_mapping = defaultdict()
    name_mapping = defaultdict()
    encoder = GEMDJson()
    nb_disregarded = 0

    if objectpath:  # plotting a graph from a single, full json (!= thin)
        with open(objectpath) as fp:
            # TODO: build gemd objects by converting them to thin jsons???
            # f = json.load(fp)
            # print(f)
            # f = str(f)
            # print(f)
            # print(type(f))
            # object = encoder.loads(f)
            object = encoder.load(fp)
            # print(len(object))
            # print(object[0])
            # exit()
        # print(object)
        # encoder.thin_dumps(object, indent=3)
        # gemd_objects = recursive_foreach(object, out, encoder, tmp)
    else:  # plotting a graph from a bunch of thin jsons
        gemd_objects = [
            os.path.join(dp, f)
            for dp, dn, filenames in os.walk(dirpath)
            for f in filenames
            if f.endswith(".json")
        ]
    if len(gemd_objects) == 0:
        return

    # adding objects to graph one by one
    for i, obj in enumerate(gemd_objects):
        if "raw_jsons" in obj:
            continue
        fp = open(obj, "r")
        obj_data = json.load(fp)
        obj_type = obj_data["type"]
        if (
            obj_type.startswith("parameter")
            or obj_type.startswith("condition")
            or obj_type.startswith("property")
        ):
            nb_disregarded += 1
            continue
        obj_uid = obj_data["uids"]["auto"]
        obj_name = obj_data["name"]
        name_mapping[obj_uid] = "{},  {}".format(obj_name, obj_uid[:3])
        handle_gemd_obj(G, obj_uid, obj_data, obj_type, obj_state, object_mapping)

    # converting to grapviz
    _relabeled_G = nx.relabel_nodes(G, name_mapping)

    relabeled_G = nx.nx_agraph.to_agraph(_relabeled_G)
    relabeled_G.node_attr.update(nodesep=0.4)
    relabeled_G.node_attr.update(ranksep=1)

    relabeled_G.layout(prog="dot")

    # plotting
    relabeled_G.draw(os.path.join(dirpath, "{}_graph.svg".format(obj_state)))
    plt.close()
    with open(os.path.join(dirpath, "{}_graph.dot".format(obj_state)), "x") as f:
        f.write(str(relabeled_G))

    # info
    print("cycles in the graph: {}".format(list(nx.simple_cycles(G))))
    print(
        "nb of disregarded elements (i.e., templates/specs): {}/{}".format(
            nb_disregarded, len(gemd_objects)
        )
    )


# def analyze(encoder, subdirpath, terminal_gemd_obj, obj_state):
#     '''
#     runs a series of tests on a set of GEMD objects. It starts by writing them to
#     subdirpath using a recursive function on the terminal gemd object in your worklow,
#     and custom plots a graph of GEMD objects.
#     :param encoder: GEMDencoder object of the current run
#     :param subdirpath: destination directory of your GEMD objects tied to a run
#     :param terminal_gemd_obj: last gemd object in the pipeline/workflow
#     :param obj_state: determins what object type to plot
#     '''
#     # delete if it already exists
#     if os.path.exists(subdirpath):
#         shutil.rmtree(subdirpath)
#     os.mkdir(subdirpath)
#     global _subdirpath
#     _subdirpath = subdirpath
#     global _encoder
#     _encoder = encoder
#     if obj_state == "run":
#         terminal_gemd_obj_entity = terminal_gemd_obj._run
#     else:
#         terminal_gemd_obj_entity = terminal_gemd_obj._spec

#     encoder.thin_dumps(terminal_gemd_obj_entity,indent=3) # this step needs to be run to instantiate
#     recursive_foreach(terminal_gemd_obj_entity, out)
#     return plot_graph(subdirpath, obj_state=obj_state)
